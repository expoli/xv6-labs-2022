Q: Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?
A: a0, the register a2 holds 13 in main's call to printf.

Q: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
A: function f: jalr -50(ra), function g: jalr	-48(ra)

Q: At what address is the function printf located?
A: the address of the function printf is 0x0000000000000a4e

Q: What value is in the register ra just after the jalr to printf in main?
A: 在 RISC-V 汇编中，jalr (Jump and Link Register) 指令跳转到由寄存器和一个立即数的偏移量确定的地址，并将返回地址（即跳转后将要执行的下一条指令的地址）存储在 ra（返回地址）寄存器中。在地址 0x6c 处的指令是一个跳转到 printf 函数的 jalr 指令。执行这条指令之后，ra 寄存器会保存返回地址，也就是在跳转返回后将要执行的下一条指令的地址。这会是 jalr 指令后面的那条指令的地址，即0x70。

Q: Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
      

What is the output? Here's an ASCII table that maps bytes to characters.

The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

A: 在 C 语言中，printf("H%x Wo%s", 57616, &i) 会将 57616 以十六进制形式打印出来，并尝试将整数 i 的地址作为一个字符串来访问。 i 的初值 0x00646c72 以十六进制形式表示，对应于 ASCII 字符的 "rld"（little-endian 下读取为 "dlr"）。
所以，按照小端方式（little-endian）解释，0x00646c72 对应的字符是 'r'(0x72), 'l'(0x6c), 'd'(0x64), 最后一个字节是字符串结束符'\0'(0x00)。57616 的十六进制值是 e110，因此 printf("H%x Wo%s", 57616, &i) 这行代码的输出将是 "He110 World"。
在大端模式（big-endian）下，0x00646c72 的解读就会完全不同，需要逆序读取字节，同时，我们也需要更改 57616 的值，因为大端方式下，更高的位于内存的低端。所以如果要产生相同的输出，你需要把 i 的值设置为 0x726c6400，这对应了 'r'(0x72), 'l'(0x6c), 'd'(0x64), '\0'(0x00)。并且，57616 (Hex: e110) 应该更改为 45825 (Hex: 10e1)，把它也逆序排列。最终代码如下：

	unsigned int i = 0x726c6400;
	printf("H%x Wo%s", 45825, &i);

Q: In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?
A: 对于 'x'，我们提供了数值3作为参数，因此 'x' 的值会被正确打印出来。然而，对于 'y'，我们并没有提供对应的参数。结果是，printf 会试图从调用堆栈上获取应该作为 'y' 的值的数值。由于并未确保堆栈上该位置有有效的参数存在，所以 'y' 的值将会是不确定的。
我们无法预先知道会打印什么值，因为这取决于在调用 printf 对应位置上堆栈的内容，这通常是未定义的。结果可能会因编译器，操作系统，机器状态，乃至你怎么编译你的代码这些因素而变化。
